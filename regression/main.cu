// main_binary_random_forest_regression.cu
//
// This file is a main CUDA source code for binary random forest regressor.
// This source file is assumed to be compiled with `model.cu`
// which will be generated by `code_generator.py`.


#include <iostream>
#include <cstring>
#include <ctime>

#include <include/cufhe_gpu.cuh>
using namespace cufhe;


////////////////////////////////////////////////////////////
// Function and variable prototype definitions.
//
// The following functions will be defined on `model.cu`
// which will be generated by `code_generator.py`.
////////////////////////////////////////////////////////////

extern int n_trees;  // Number of trees (estimators).
extern int n_nodes;  // Number of nodes in a tree.
extern int n_input;  // Length of input data.

void prediction(Ctxt *c, Ctxt *c_const, Ctxt **o);
    // Prediction of binary random forest on T-FHE scheme.
    // 
    //
    // Args:
    //     c       (Ctxt*) : Input cipher text array with length `n_input`.
    //     d       (Ctxt*) : Negation of c (i.e. c[n] == !d[n] for all n).
    //     o       (Ctxt**): Output data array with shape (n_trees, n_nodes).
    //     c_const (Ctxt*) : Encryptions of constant 0 and 1.
    //
    // Returns:
    //     Nothing. Prediction results will be stored in the array `o`.

double get_result(Ctxt **o, PriKey &pri_key);
    // Get result of binary random forest on T-FHE scheme.
    // 
    // Args:
    //     o       (Ctxt**): Output data array with shape (n_trees, n_nodes).
    //     pri_key (PriKey): 
    //
    // Returns:
    //     (double) Prediction result.


////////////////////////////////////////////////////////////
// Gobal variables
//
// Variables defined here will also be used in `model.cu`.
////////////////////////////////////////////////////////////

uint32_t n_stream;  // Number of GPU streams.
Stream*  stream;    // Stream instances.


////////////////////////////////////////////////////////////
// File-wise gobal variables
//
// The following variables are globally used in this file,
// but not shared to `model.cu`.
////////////////////////////////////////////////////////////

static PriKey pri_key;  // Private key.
static PubKey pub_key;  // Public key.


////////////////////////////////////////////////////////////
// Data loader
//
// The following function loads input data from command
// line argument, parse it and returns encrypted input
// array as `Ctxt*`.
////////////////////////////////////////////////////////////

void read_input_data(char *src, Ptxt *p, Ctxt *c) {
    // read input data from command line and encrypt it.
    // 
    // Args:
    //     src (char*): String expression of input data (e.g. "01001...").
    //     p   (Ptxt*): Binary expression of the plain input data.
    //     c   (Ptxt*): Binary expression of the encrypted input data.
    //
    // Returns:
    //     Nothing.

    // Assertion: length of the input data should match with `n_input` which is
    // derived from the Scikit-learn model (written in `model.cu`).
    if (strnlen(src, n_input) != n_input)
    {
        std::cout << "The pre-trained model requires " << n_input << "-dim inputs, ";
        std::cout << "but " << strnlen(src, n_input) << "-dim input given." << std::endl;
        exit(EXIT_FAILURE);
    }

    // Read input argument and convert it as `Ptxt`.
    for (size_t n = 0; n < n_input; ++n)
    {
        switch (src[n])
        {
            case '0': p[n].message_ = 0; break;
            case '1': p[n].message_ = 1; break;
            default : std::cout << "Input value should be 0 or 1." << std::endl; exit(EXIT_FAILURE);
        }
    }

    // Encryption.
    for (size_t n = 0; n < n_input; ++n)
        Encrypt(c[n], p[n], pri_key);
}

void initialize(Ptxt *p_const, Ctxt *c_const) {
    // Initialize devices for cuFHE library.
    //
    // Args:
    //
    // Returns:
    //     Nothing. The encrypted constants will be stored in `c_const`.

    // Initialize GPU.
    cudaSetDevice(1);
    cudaDeviceProp prop;
    cudaGetDeviceProperties(&prop, 1);

    // Initialize GPU streams.
    n_stream = prop.multiProcessorCount;
    stream = new Stream[n_stream];
    for (int n = 0; n < n_stream; ++n)
        stream[n].Create();

    // Set random seed.
    SetSeed();
    Synchronize();

    // Public and private key generation.
    std::cout << ":: Key Generation" << std::endl;
    KeyGen(pub_key, pri_key);
    Synchronize();

    std::cout << ":: Initilizating Data on GPU(s)" << std::endl;
    Initialize(pub_key);

    // Encrypt constants.
    for (int n = 0; n < 2; ++n)
    {
        p_const[n].message_ = n;
        Encrypt(c_const[n], p_const[n], pri_key);
    }
}

void finalize() {
    // Finalize devices.
    //
    // Returns:
    //     Nothing.

    std::cout << ":: Destroy streams" << std::endl;
    for (int n = 0; n < n_stream; n++)
        stream[n].Destroy();
    delete[] stream;

    // Essential to clean and deallocate data on GPUs.
    std::cout << ":: Clean Data on GPU(s)" << std::endl;
    CleanUp();
}

int main(int argc, char *argv[]) {
    // Entry point of the software.
    //
    // Args:
    //     argc (int)    : Number of command line arguments.
    //     argv (char*[]): Contents of command line arguments.
    //
    // Returns:
    //     (int) Exit status.

    // Abort if no input data given.
    if (argc < 2)
    {
        std::cout << "No input data found, abort." << std::endl;
        exit(EXIT_FAILURE);
    }

    // Initialize devices.
    std::cout << ":: Initialize devices" << std::endl;
    Ptxt *p_const = new Ptxt[2];  // Plain text of the input data.
    Ctxt *c_const = new Ctxt[2];  // Cipher text of the input data.
    initialize(p_const, c_const);
    std::cout << "    - n_stream = " << n_stream << std::endl;

    // Read input data.
    std::cout << ":: Read input data and encryption" << std::endl;
    Ptxt *p = new Ptxt[n_input];
    Ctxt *c = new Ctxt[n_input];
    read_input_data(argv[1], p, c);

    // Allocate output data structure.
    std::cout << ":: Allocate the output data structure" << std::endl;
    Ctxt **o = new Ctxt*[n_trees];
    for (int n = 0; n < n_trees; ++n)
    {
        o[n] = new Ctxt[n_nodes];
        for (int m = 0; m < n_nodes; ++m)
            Encrypt(o[n][m], p_const[0], pri_key);
    }

    // Prediction.
    std::cout << ":: Prediction" << std::endl;
    prediction(c, c_const, o);

    // Get result.
    std::cout << ":: Get result" << std::endl;
    double result = get_result(o, pri_key);
    std::cout << "    - y_pred = " << result << std::endl;

    // Run predictions many times for measuring fair computational time.
    int n_trials = 30;
    std::cout << ":: Prediction (n_trials = " << n_trials << ")" << std::endl;
    time_t start = clock();
    for (int n = 0; n < n_trials; ++n)
        prediction(c, c_const, o);
    time_t end = clock();
    time_t proctime = static_cast<double>(end - start) / CLOCKS_PER_SEC * 1000.0;
    std::cout << "    - time = " << proctime / n_trials << "[ms]" << std::endl;

    // Finalize devices.
    std::cout << ":: Finalize devices" << std::endl;
    finalize();

    // Free allocated variables.
    std::cout << ":: Free allocated variables" << std::endl;
    for (int n = 0; n < n_trees; ++n)
        delete[] o[n];
    delete[] p, p_const, c, c_const, o;

    return EXIT_SUCCESS;
}

// vim: expandtab tabstop=4 shiftwidth=4 fdm=marker
